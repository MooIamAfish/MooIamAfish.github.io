<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>小菜鸡</title>
  
  <subtitle>活着没意思</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://MoolamAfish.com/"/>
  <updated>2017-12-22T03:35:49.181Z</updated>
  <id>http://MoolamAfish.com/</id>
  
  <author>
    <name>amy</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>ES_install</title>
    <link href="http://MoolamAfish.com/2017/12/22/ES-install/"/>
    <id>http://MoolamAfish.com/2017/12/22/ES-install/</id>
    <published>2017-12-22T02:48:14.000Z</published>
    <updated>2017-12-22T03:35:49.181Z</updated>
    
    <content type="html"><![CDATA[<h1 id="ElasticSearch笔记"><a href="#ElasticSearch笔记" class="headerlink" title="ElasticSearch笔记"></a>ElasticSearch笔记</h1><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><h3 id="Near-Realtime-NRT"><a href="#Near-Realtime-NRT" class="headerlink" title="Near Realtime(NRT)"></a>Near Realtime(NRT)</h3><p>ES是一款近实时的搜索平台，也就是说，提交索引到出结果会有轻微的延迟（通常约1s）</p><h3 id="集群"><a href="#集群" class="headerlink" title="集群"></a>集群</h3><p>一个集群包含了单个或多个节点（server），这些节点保存了所有的数据，并且提供了跨节点的联合索引和搜索功能。一个集群有一个唯一的标示名称，默认是 elasticsearch。这个名称非常重要，节点是根据集群的名称加入集群的，且单个节点只能是一个集群的一部分。</p><p>要确保在不同的开发环境下不重用相同的集群名称，否则你的节点会加入到错误的集群。例如，你可以使用 logging-dev, logging-stage, logging-prod 分别针对开发，测试和生产环境。</p><p>请注意：集群只有一个节点是完全合法的，此外，你也可以有多个独立的集群，每个集群的名称唯一。</p><h3 id="节点"><a href="#节点" class="headerlink" title="节点"></a>节点</h3><p>节点就是一台服务器，它是集群的一部分，保存了数据并且参与了集群的索引和搜索。与集群一样，节点也有唯一的标示符，它是一个随机的传奇人物名称，在集群启动的时候被分配给节点。如果你不想使用默认的名称，你可以使用任何你想要的名称。名称的重要性是出于管理目的，因为你需要知道网络中的服务器对应集群中的哪一个节点。</p><p>节点可以通过配置集群名称加入指定的集群。默认地，每个节点会被加入到名为 elasticsearch 的集群，这就意味着如果你在网络中启动一系列的节点，假设这些节点可以彼此发现，它们会自动的联结并加入到名为 elasticsearch 的集群。</p><p>一个单独的集群可以有任意数量的节点。此外，如果没有其他的 Elasticsearch 节点运行在你的网络中，启动一个单独的节点会默认自动加入到名为 elasticsearch 的集群。</p><h3 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h3><p>索引是一系列有相似特征文档（document）的集合。例如，你有一个顾客数据的索引，一个产品类别的索引，还有一个订单数据索引。索引被一个名称（必须都为小写）所标示，这个名称在索引，搜索，更新和删除文档的时候被使用。</p><p>在一个单独的集群中，你可以定义任意数量的索引。</p><h3 id="文档"><a href="#文档" class="headerlink" title="文档"></a>文档</h3><p>文档是可以被索引的基本数据单元。例如，你可以针对一个顾客建立一个文档，针对一个产品建立一个文档，也可以根据一个订单建立一个文档。文档使用 JSON(JavaScript Object Notation)数据格式，它是被广泛使用的互联网数据交换格式。</p><p>在索引当中，你可以存储任意数量的文档。注意，虽然文档在物理上是驻留在索引当中，但是文档实际上必须被索引或分配到索引内部的一个类型（type）当中。</p><h3 id="分片和副本"><a href="#分片和副本" class="headerlink" title="分片和副本"></a>分片和副本</h3><p>索引可以存储大量的数据，并且可以突破单个节点的硬件限制。例如，一个包涵10亿文档的索引会占据1TB的磁盘，单个节点也许无法容纳这么多的数据，也可能无法快速响应搜索请求。</p><p>为了解决这个问题，Elasticsearch 提供了将索引切分成多个分片的能力。当你创建索引的时候，你可以指定分片的数量。每一个分片本身是拥有完整功能和独立的索引，可以放置在集群中的任意节点。</p><p>分片的重要性主要体现在两个方面：<br>可以水平的切分／扩展数据集。  允许跨分片的分配和并行化操作以提高性能和吞吐量。</p><p>分片的分配机制和文档聚合回搜索请求的机制是完全由 Elasticsearch 管理的，对用户是透明的。</p><p>在网络／云环境下，失败是无法避免的，一旦分片／节点因为某些原因下线或消失，强烈推荐使用故障转移机制，为此，Elasticsearch 允许你为分片设置一份或多份拷贝，这些拷贝被称作副本分片，简称副本。</p><p>副本的重要性体现在两个方面：<br>  一旦分片／节点出现故障，它提供了高可用性。基于这个原因，副本分片和原始分片不在同一个节点是非常有必要的。<br>    因为搜索可以并行的在所有的副本上执行，因此可以扩大搜索数据集和吞吐量。</p><p>总的来说，每个索引都可以被切割成多个分片，每个索引也可以被复制零次（意味着没有副本）或多次。一旦索引被复制，每个分片就有主分片（被复制前的原始分片）和副本分片（主分片的副本）之分。分片和副本的数量可以在索引被创建的时候指定。索引创建之后，你可以动态的改变副本的数量，但是你无法改变分片的数量。</p><p>默认情况下，Elasticsearch 中的索引会产生5个主分片和一个副本。如果你的集群有两个节点，每个索引将会有5个主分片和5个副本分片，总共10个分片。</p><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><h3 id="基本集群安装"><a href="#基本集群安装" class="headerlink" title="基本集群安装"></a>基本集群安装</h3><ul><li>安装java</li><li>下载基础软件包：  </li></ul><pre><code>curl -L -O https://artifacts.elastic.co/downloads/elasticsearch/elasticsearch-5.6.3.tar.gz</code></pre><ul><li>解压并进入目录</li></ul><pre><code>tar -xvf elasticsearch-5.6.3.tar.gzcd elasticsearch-5.6.3</code></pre><ul><li>创建非root用户并赋予权限</li></ul><pre><code>groupadd elsuseradd els -g els -p ***chown  -R els:els elasticsearch-5.6.3</code></pre><ul><li>更改配置文件 config/elasticsearch.yml</li></ul><pre><code>cluster.name: ElasticSearchTest    # 集群名，位于同一集群的节点此配置相同network.host: 192.168.1.145    #绑定地址，此处为本节点IPdiscovery.zen.ping.unicast.hosts: [&quot;192.168.1.145&quot;,&quot;192.168.1.144&quot;]    #多播主机IPhttp.port: 9200    #端口号</code></pre><ul><li>修改/etc/security/limits.conf</li></ul><pre><code>* soft nofile 65536* hard nofile 131072* soft nproc 2048* hard nproc 4096</code></pre><ul><li>修改 /etc/security/limits.d/90-nproc.conf </li></ul><pre><code>* soft nproc 2048</code></pre><ul><li>修改 /etc/sysctl.conf</li></ul><pre><code>vm.max_map_count=655360</code></pre><ul><li>执行</li></ul><pre><code>sysctl -p</code></pre><ul><li>启动ES</li></ul><pre><code>. elasticsearch -d</code></pre><ul><li>验证<br><a href="http://IP:9200" target="_blank" rel="noopener">http://IP:9200</a><br>{<br>“name” : “ox2”,<br>“cluster_name” : “ElasticSearchTest”,<br>“cluster_uuid” : “6oNSPC4OQ7q6Ip2IqRQ50Q”,<br>“version” : {<br>  “number” : “5.6.3”,<br>  “build_hash” : “1a2f265”,<br>  “build_date” : “2017-10-06T20:33:39.012Z”,<br>  “build_snapshot” : false,<br>  “lucene_version” : “6.6.1”<br>},<br>“tagline” : “You Know, for Search”<br>}</li></ul><hr><h3 id="head安装"><a href="#head安装" class="headerlink" title="head安装"></a>head安装</h3><ul><li>下载软件包，解压</li></ul><pre><code>wget  https://github.com/mobz/elasticsearch-head/archive/master.zip</code></pre><ul><li>安装nodejs,npm</li></ul><pre><code>wget https://npm.taobao.org/mirrors/node/latest-v4.x/node-v4.4.7-linux-x64.tar.gz</code></pre><ul><li>配置JAVA_HOME, NODE_HOME,PATH</li><li>进入head目录，执行</li></ul><pre><code>npm install -g grunt-cli npm install #   如果速度较慢或者安装失败，可以使用国内镜像:npm install -g cnpm --registry=https://registry.npm.taobao.org</code></pre><ul><li>修改配置文件编辑elasticsearch-5.1.1/config/elasticsearch.yml,加入以下内容：</li></ul><pre><code>http.cors.enabled: true  http.cors.allow-origin: &quot;*&quot;</code></pre><ul><li>修改HEAD目录下Gruntfile.js，找到以下内容并添加hostname项</li></ul><pre><code>connect: {    server: {        options: {            port: 9100,            base: &apos;.&apos;,            hostname:&apos;*&apos;,            keepalive: true        }    }}   </code></pre><ul><li>修改/home/ntc/code/elasticsearch-head/_site/app.js中head的连接地址（如果配主机名，本机访问时要在本机配DNS）</li></ul><pre><code>this.base_uri = this.config.base_uri || this.prefs.get(&quot;app-base_uri&quot;) || &quot;http://192.168.40.133:9200&quot;;</code></pre><ul><li>运行head,在head目录下执行</li></ul><pre><code>grunt server &amp;</code></pre><hr><h3 id="中文分词安装"><a href="#中文分词安装" class="headerlink" title="中文分词安装"></a>中文分词安装</h3><h4 id="网络安装"><a href="#网络安装" class="headerlink" title="网络安装"></a>网络安装</h4><pre><code>./bin/elasticsearch-plugin install https://github.com/medcl/elasticsearch-analysis-ik/releases/download/v5.5.1/elasticsearch-analysis-ik-5.5.1.zip      #  将数字部分根据版本号替换</code></pre><h4 id="离线环境"><a href="#离线环境" class="headerlink" title="离线环境"></a>离线环境</h4><ul><li>解下zip包之后，将config文件夹拷贝到ES_HOME下config文件夹下，并更名为analysis-ik</li><li>将其余文件（jar包和配置文件）拷贝到ES_HOME下plugins/analysis-ik文件夹下</li><li>重启ES</li></ul><hr><h3 id="Kibana安装"><a href="#Kibana安装" class="headerlink" title="Kibana安装"></a>Kibana安装</h3><ul><li>下载安装包并解压<br><a href="https://artifacts.elastic.co/downloads/kibana" target="_blank" rel="noopener">https://artifacts.elastic.co/downloads/kibana</a></li><li>改配置文件KIBANA_HOME/config/kibana.yml</li></ul><pre><code>elasticsearch.url: &quot;http://192.168.1.145:9200&quot;server.host: &quot;192.168.1.145&quot;  </code></pre><ul><li>执行<br>./bin/kibana &amp;</li></ul><hr><h3 id="Logstash安装"><a href="#Logstash安装" class="headerlink" title="Logstash安装"></a>Logstash安装</h3><ul><li>下载软件包<br><a href="https://www.elastic.co/downloads/logstash" target="_blank" rel="noopener">https://www.elastic.co/downloads/logstash</a></li><li>新增logstash.conf文件</li></ul><pre><code>input { file {   path =&gt; [&quot;/var/opt/log/a.log&quot;,&quot;/var/opt/log/b.log&quot;] } }  output {  elasticsearch { hosts =&gt; [&quot;ox1:9200&quot;] }  stdout { codec =&gt; rubydebug }}</code></pre><ul><li><p>执行<br>./bin/logstash -f conf/logstash-indexer.conf</p></li><li><p>安装完成之后，在path里指定的文件中输入文字，可以在终端/9200中看到结果</p></li></ul><h2 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h2><h4 id="索引-index"><a href="#索引-index" class="headerlink" title="索引(index)"></a>索引(index)</h4><h5 id="新建索引"><a href="#新建索引" class="headerlink" title="新建索引"></a>新建索引</h5><pre><code>curl -X PUT &apos;localhost:9200/weather&apos;需要指定中文分词的索引  curl -X PUT &apos;localhost:9200/accounts&apos; -d &apos;{ &quot;mappings&quot;: {   &quot;person&quot;: {    &quot;properties&quot;: {      &quot;user&quot;: {         &quot;type&quot;: &quot;text&quot;,         &quot;analyzer&quot;: &quot;ik_max_word&quot;,         &quot;search_analyzer&quot;: &quot;ik_max_word&quot;       },      &quot;title&quot;: {        &quot;type&quot;: &quot;text&quot;,        &quot;analyzer&quot;: &quot;ik_max_word&quot;,        &quot;search_analyzer&quot;: &quot;ik_max_word&quot;      },        &quot;desc&quot;: {          &quot;type&quot;: &quot;text&quot;,          &quot;analyzer&quot;: &quot;ik_max_word&quot;,          &quot;search_analyzer&quot;: &quot;ik_max_word&quot;        }      }    }  }}&apos;</code></pre><h5 id="删除索引"><a href="#删除索引" class="headerlink" title="删除索引"></a>删除索引</h5><pre><code>curl -X DELETE &apos;localhost:9200/weather&apos;</code></pre><h5 id="查询索引"><a href="#查询索引" class="headerlink" title="查询索引"></a>查询索引</h5><pre><code> 查询所有索引  curl -X GET &apos;http://localhost:9200/_cat/indices?v&apos;</code></pre><h4 id="记录-document"><a href="#记录-document" class="headerlink" title="记录(document)"></a>记录(document)</h4><h5 id="新增记录"><a href="#新增记录" class="headerlink" title="新增记录"></a>新增记录</h5><pre><code>   #指定id为1curl -X PUT &apos;localhost:9200/accounts/person/1&apos; -d &apos;   { &quot;user&quot;: &quot;张三&quot;,  &quot;title&quot;: &quot;工程师&quot;,  &quot;desc&quot;: &quot;数据库管理&quot;}&apos; # 不指定id ，为随机值，此时为POST方法 curl -X POST &apos;localhost:9200/accounts/person&apos; -d &apos;{ &quot;user&quot;: &quot;李四&quot;,  &quot;title&quot;: &quot;工程师&quot;,  &quot;desc&quot;: &quot;系统管理&quot;}&apos;</code></pre><h5 id="查询记录"><a href="#查询记录" class="headerlink" title="查询记录"></a>查询记录</h5><pre><code>curl &apos;localhost:9200/accounts/person/1?pretty=true&apos;</code></pre><h5 id="删除记录"><a href="#删除记录" class="headerlink" title="删除记录"></a>删除记录</h5><pre><code>curl -X DELETE &apos;localhost:9200/accounts/person/1&apos;</code></pre><h5 id="更新数据"><a href="#更新数据" class="headerlink" title="更新数据"></a>更新数据</h5><pre><code> curl -X PUT &apos;localhost:9200/accounts/person/1&apos; -d &apos;{   &quot;user&quot; : &quot;张三&quot;,    &quot;title&quot; : &quot;工程师&quot;,    &quot;desc&quot; : &quot;数据库管理，软件开发&quot;}&apos;</code></pre><h4 id="数据操作"><a href="#数据操作" class="headerlink" title="数据操作"></a>数据操作</h4><h5 id="返回所有记录"><a href="#返回所有记录" class="headerlink" title="返回所有记录"></a>返回所有记录</h5><pre><code>curl &apos;localhost:9200/accounts/person/_search&apos;</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;ElasticSearch笔记&quot;&gt;&lt;a href=&quot;#ElasticSearch笔记&quot; class=&quot;headerlink&quot; title=&quot;ElasticSearch笔记&quot;&gt;&lt;/a&gt;ElasticSearch笔记&lt;/h1&gt;&lt;h2 id=&quot;概念&quot;&gt;&lt;a href=&quot;
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>MRExample</title>
    <link href="http://MoolamAfish.com/2017/12/15/MRExample-1/"/>
    <id>http://MoolamAfish.com/2017/12/15/MRExample-1/</id>
    <published>2017-12-15T06:55:14.000Z</published>
    <updated>2017-12-15T06:56:22.157Z</updated>
    
    <content type="html"><![CDATA[<h1 id="12"><a href="#12" class="headerlink" title="12"></a>12</h1><h2 id="123"><a href="#123" class="headerlink" title="123"></a>123</h2>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;12&quot;&gt;&lt;a href=&quot;#12&quot; class=&quot;headerlink&quot; title=&quot;12&quot;&gt;&lt;/a&gt;12&lt;/h1&gt;&lt;h2 id=&quot;123&quot;&gt;&lt;a href=&quot;#123&quot; class=&quot;headerlink&quot; title=&quot;123&quot;&gt;&lt;/a&gt;123&lt;/h2&gt;
      
    
    </summary>
    
    
      <category term="mapreduce" scheme="http://MoolamAfish.com/tags/mapreduce/"/>
    
  </entry>
  
  <entry>
    <title>first</title>
    <link href="http://MoolamAfish.com/2017/12/15/MRExample/"/>
    <id>http://MoolamAfish.com/2017/12/15/MRExample/</id>
    <published>2017-12-15T06:02:13.000Z</published>
    <updated>2017-12-15T06:18:11.860Z</updated>
    
    <content type="html"><![CDATA[<p>这是我的第一篇博客</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;这是我的第一篇博客&lt;/p&gt;

      
    
    </summary>
    
    
      <category term="webpack" scheme="http://MoolamAfish.com/tags/webpack/"/>
    
      <category term="vue" scheme="http://MoolamAfish.com/tags/vue/"/>
    
  </entry>
  
  <entry>
    <title>webpack3+vue2 项目搭建(without vue-cli)</title>
    <link href="http://MoolamAfish.com/2017/12/13/%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/"/>
    <id>http://MoolamAfish.com/2017/12/13/搭建博客/</id>
    <published>2017-12-13T09:47:18.000Z</published>
    <updated>2017-12-22T04:49:29.013Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>Vue-cli是官方提供的快速构建单页应用的脚手架，按官方文档跑了一遍确实非常强大，但牵扯的东西比较多，所以存在了一些疑惑，比如说整个项目是怎么组织运行起来的，main.js-APP.vue-各个组件之间是怎样相互引用的？为了加深自己的理解，不借助官方构建工具，利用webpack3+vue2自行构建一个类似于官方的项目结构，去体会它的运作机制。</p><h3 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h3><p>安装node.js<br>根据自己的操作系统去<a href="http://nodejs.cn/download/" target="_blank" rel="noopener">官网</a>下载安装包,安装完毕之后就可以使用npm了。npm是随同node.js一起安装的包管理工具，允许用户从npm服务器下载别人编写的第三方包到本地使用；允许用户从npm服务器下载并安装别人编写的命令行程序到本地使用；允许用户将自己编写的包或命令行程序上传到NPM服务器供别人使用。<br>npm的包安装分本地安装跟全局安装：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ npm install &lt;Module Name&gt;      # 本地安装</span><br><span class="line">$ npm install &lt;Module Name&gt; -g   # 全局安装</span><br></pre></td></tr></table></figure><br>因为npm是从国外服务器下载包，受网络影响大，可能出现异常，因此淘宝团队做了一个完整 npmjs.org 镜像，你可以用此代替官方版本(只读)，同步频率目前为 10分钟 一次以保证尽量与官方服务同步,所以你可以使用定制的cnpm命令行工具代替默认的npm：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ npm install -g cnpm --registry=https://registry.npm.taobao.org</span><br></pre></td></tr></table></figure></p><h3 id="开始"><a href="#开始" class="headerlink" title="开始"></a>开始</h3><p>1.新建一个文件夹,进入项目根目录，初始化npm<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mkdir vue-webpack</span><br><span class="line">cd vue-webpack</span><br><span class="line">npm init</span><br></pre></td></tr></table></figure><br>然后会让你输入文件名，版本，描述等信息，一路回车就好，最后根目录下面会产生一个package.json文件，这是一个标准的npm说明文件，里面蕴含了丰富的信息，包括当前项目的依赖模块，自定义的脚本任务等等。<br>2.安装vue包到项目<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install --save vue</span><br></pre></td></tr></table></figure><br>注意：npm在安装vue包时，有两种命令参数可以把它们的信息写入package.json文件，一个是npm install - -save，另一个是npm install - -save-dev，- -save会把依赖包名称添加到package.json文件的dependencies 键下，而- -save-dev则把依赖包名称添加到devDependencies 键下。npm文档解释dependencies是运行时依赖，devDependencies是开发时的依赖。即devDependencies 下列出的模块，是我们开发时用的，dependencies下的模块，则是我们发布后还需要依赖的模块，譬如像Vue框架，我们在开发完后肯定还要依赖它，否则就运行不了。<br>3.创建目录结构<br>在根目录下创建src文件夹，dist文件夹和index.html，接下来在src文件夹下面创建入口文件main.js，项目根组件App.js和组件目录components，并且components目录下创建两个组件component1.js和components2.js，当前目录结构如下：<br><img src="/assets/blogImg/folder.png" alt=""></p><h3 id="组件"><a href="#组件" class="headerlink" title="组件"></a>组件</h3><p>components文件夹下存放的是项目中的除根组件外的其他组件，我们在写这些组件的时候应该遵循的一个原则就是：与外界隔绝，不做任何与外界耦合的假设。首先编写组件component1.js跟component2.js：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">export default&#123;</span><br><span class="line">   template: &apos;&lt;p&gt;&lt;/p&gt;&apos;,</span><br><span class="line">   props: &#123;</span><br><span class="line">message:&#123;</span><br><span class="line">type:String,</span><br><span class="line">default: &apos;this is compontent1&apos;</span><br><span class="line">&#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">export default&#123;</span><br><span class="line">   template: &apos;&lt;p&gt;&lt;/p&gt;&apos;,</span><br><span class="line">   props: &#123;</span><br><span class="line">message:&#123;</span><br><span class="line">type:String,</span><br><span class="line">default: &apos;this is compontent2&apos;</span><br><span class="line">&#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>接下来我们需要在根组件中引用这两个组件，根组件的写法遵循同样的原则：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">import component1 from &apos;./components/component1.js&apos;</span><br><span class="line">import component2 from &apos;./components/component2.js&apos;</span><br><span class="line">export default&#123;</span><br><span class="line">   template: &quot;&lt;div&gt;&lt;h1&gt;this is vue app&lt;/h1&gt;&lt;component1&gt;&lt;/component1&gt;&lt;component2&gt;&lt;/component2&gt;&lt;/div&gt;&quot;,</span><br><span class="line">   components: &#123;</span><br><span class="line">&apos;component1&apos;: component1,</span><br><span class="line">&apos;component2&apos;: component2,</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>要使用组件，首先要将其import导入，因为组件中导出的写法是export default，所以我们在这可以给组件对象随意命名（import后紧随的’component1’就是我们的命名），这是ES6的语法规则。记住：每个组件对象我们都需要使用export default进行导出，因为这样外界才可以调用它，并且将 给此组件的命名权 递交给使用者。<br>我们看到，在根组件中我们有components选项，用来注册将使用的组件（局部注册），此选项对象中的key将作为模板中标签，value为其他组件对象。</p><h3 id="入口"><a href="#入口" class="headerlink" title="入口"></a>入口</h3><p>组件都写好了，那如何将其挂载到html页面中呢，这个时候我们需要一个桥梁，就是main.js：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">import component1 from &apos;./components/component1.js&apos;</span><br><span class="line">import component2 from &apos;./components/component2.js&apos;</span><br><span class="line">import Vue from &apos;vue&apos;</span><br><span class="line">import app from &apos;./App.js&apos;</span><br><span class="line">new Vue(&#123;</span><br><span class="line">template: &apos;&lt;app&gt;&lt;/app&gt;&apos;,</span><br><span class="line">components: &#123;&apos;app&apos;:app&#125;</span><br><span class="line">&#125;).$mount(&apos;#app&apos;)</span><br></pre></td></tr></table></figure><br>首先导入Vue，接着导入App根组件，将其注册为Vue实例的组件，并且在模板中使用它（template:’’），然后将这个Vue实例挂载到index.html中id为app的元素中。</p><h3 id="打包"><a href="#打包" class="headerlink" title="打包"></a>打包</h3><p>在打包之前我们需要先修改vue npm包的package.json文件，将默认导出的‘只包含运行时’改为‘完整版’，即将如下两项的’runtime’去掉（运行时不包含编译器 | 编译器作用：用来将模板字符串编译成为 JavaScript 渲染函数的代码&gt;，因此组件对象不支持 template 选项）：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&quot;main&quot;: &quot;dist/vue.common.js&quot;,</span><br><span class="line">&quot;module&quot;: &quot;dist/vue.esm.js&quot;,</span><br></pre></td></tr></table></figure><br>WebPack可以看做是模块打包机：它做的事情是，分析你的项目结构，找到JavaScript模块以及其它的一些浏览器不能直接运行的拓展语言（Scss，TypeScript等），并将其转换和打包为合适的格式供浏览器使用。<br>Webpack可以使用npm安装，首先全局安装，然后安装到项目目录：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">npm install -g webpack</span><br><span class="line">npm install --save-dev webpack</span><br></pre></td></tr></table></figure><br>安装完成后，webpack可以在终端中使用，在基本的使用方法如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">webpack &#123;entry file&#125; &#123;destination for bundled file&#125;   # &#123;extry file&#125;处填写入口文件的路径  &#123;destination for bundled file&#125;处填写打包文件的存放路径</span><br></pre></td></tr></table></figure><br>在本项目中，入口文件是src目录下的main.js，我们把打包命名为main.bundle.js存放在dist目录下，因此在项目根目录下执行：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">webpack ./src/main.js ./dist/main.bundle.js</span><br></pre></td></tr></table></figure><br>执行完成之后我们可以在dist目录下看到打包好的文件，现在我们将打包好的文件引入index页面：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;meta charset=&quot;utf-8&quot;&gt;</span><br><span class="line">    &lt;title&gt;Vue App&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;div id=&quot;app&quot;&gt;&lt;/div&gt;</span><br><span class="line">&lt;script type=&quot;text/javascript&quot; src=&quot;dist/main.bundle.js&quot;&gt;&lt;/script&gt;&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure><br>现在打开index.html，可以看到如下结果：<br><img src="/assets/blogImg/index.png" alt=""><br>有没有很激动？单你肯定觉得这条指令比较复杂，在终端进行复杂的操作其实不太方便且容易出错，因此可以通过配置文件来使用webpack。</p><h3 id="通过配置文件来使用webpack"><a href="#通过配置文件来使用webpack" class="headerlink" title="通过配置文件来使用webpack"></a>通过配置文件来使用webpack</h3><p>webpack拥有很多其他的比较高级的功能，这些功能其实都可以通过命令行模式实现，但是这样不太方便且容易出错，解决方法就是定义一个配置文件，这个配置文件其实也是一个简单的javascript模块，我们可以把所有与打包相关的信息放在里面。<br>现在我们在根目录下新建webpack.config.js文件，在其中做简单的配置，目前的配置主要涉及到的内容是入口文件路径和打包后文件的存放路径。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">module.exports = &#123;</span><br><span class="line">  entry:  __dirname + &quot;/src/main.js&quot;,//已多次提及的唯一入口文件</span><br><span class="line">  output: &#123;</span><br><span class="line">    path: __dirname + &quot;/dist&quot;,//打包后的文件存放的地方</span><br><span class="line">    filename: &quot;main.bundle.js&quot;//打包后输出文件的文件名</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>“__dirname”是node.js中的一个全局变量，它指向当前执行脚本所在的目录。有了这个配置之后，再打包文件，只需在终端里运行webpack命令就可以了，这条命令会自动引用webpack.config.js文件中的配置选项。</p><h3 id="更快捷的执行打包任务"><a href="#更快捷的执行打包任务" class="headerlink" title="更快捷的执行打包任务"></a>更快捷的执行打包任务</h3><p>由于npm可以引导任务执行，在对npm进行配置后可以在命令行中使用简单的npm start命令来替代上面的webpack命令。在package.json中对scripts对象进行相关的设置即可，设置方法如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&quot;scripts&quot;: &#123;</span><br><span class="line">    &quot;test&quot;: &quot;echo \&quot;Error: no test specified\&quot; &amp;&amp; exit 1&quot;,</span><br><span class="line">    &quot;start&quot; : &quot;webpack&quot;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><br>npm的start命令是一个特殊的脚本名称，其特殊性表现在，在命令行中使用npm start就可以执行其对于的命令，如果对应的此脚本名称不是start，想要在命令行中运行时，需要这样用npm run {script name}如npm run build，现在我们在命令行中输入npm start就可以同样完成打包了。</p><h3 id="Webpack的强大功能"><a href="#Webpack的强大功能" class="headerlink" title="Webpack的强大功能"></a>Webpack的强大功能</h3><p>使用webpack构建本地服务器<br>想不想让你的浏览器监听你的代码的修改，并自动刷新显示修改后的结果，其实Webpack提供一个可选的本地开发服务器，这个本地服务器基于node.js构建，可以实现你想要的这些功能，不过它是一个单独的组件，在webpack中进行配置之前需要单独安装它作为项目依赖。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install --save-dev webpack-dev-server</span><br></pre></td></tr></table></figure><br>devserver作为webpack配置选项中的一项，以下是它的一些配置选项，更多配置可参考<a href="https://webpack.js.org/configuration/dev-server/" target="_blank" rel="noopener">这里</a><br><img src="/assets/blogImg/devserver.png" alt=""><br>把这些命令加到webpack的配置文件中，现在的配置文件webpack.config.js如下所示：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">module.exports = &#123;</span><br><span class="line">  entry:  __dirname + &quot;/src/main.js&quot;,//已多次提及的唯一入口文件</span><br><span class="line">  output: &#123;</span><br><span class="line">    path: __dirname + &quot;/dist&quot;,//打包后的文件存放的地方</span><br><span class="line">    filename: &quot;main.bundle.js&quot;//打包后输出文件的文件名</span><br><span class="line">  &#125;,</span><br><span class="line">  devServer: &#123;</span><br><span class="line">    contentBase: &quot;./&quot;,//本地服务器所加载的页面所在的目录</span><br><span class="line">    historyApiFallback: true,//不跳转</span><br><span class="line">    inline: true//实时刷新</span><br><span class="line">  &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>在package.json中的scripts对象中添加如下命令，用以开启本地服务器：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&quot;scripts&quot;: &#123;</span><br><span class="line">    &quot;test&quot;: &quot;echo \&quot;Error: no test specified\&quot; &amp;&amp; exit 1&quot;,</span><br><span class="line">    &quot;start&quot; : &quot;webpack&quot;,</span><br><span class="line">    &quot;server&quot;: &quot;webpack-dev-server --open&quot;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><br>在终端中输入npm run server即可在本地的8080端口查看结果。</p><h3 id="插件（Plugins）"><a href="#插件（Plugins）" class="headerlink" title="插件（Plugins）"></a>插件（Plugins）</h3><p>插件（Plugins）是用来拓展Webpack功能的，它们会在整个构建过程中生效，执行相关的任务。Webpack有很多内置插件，同时也有很多第三方插件，可以让我们完成更加丰富的功能。要使用某个插件，我们需要通过npm安装它，然后要做的就是在webpack配置中的plugins关键字部分添加该插件的一个实例（plugins是一个数组）继续上面的例子，我们添加了一个给打包后代码添加版权声明的插件。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">const webpack = require(&apos;webpack&apos;);</span><br><span class="line">module.exports = &#123;</span><br><span class="line">  entry:  __dirname + &quot;/src/main.js&quot;,//已多次提及的唯一入口文件</span><br><span class="line">  output: &#123;</span><br><span class="line">    path: __dirname + &quot;/dist&quot;,//打包后的文件存放的地方</span><br><span class="line">    filename: &quot;main.bundle.js&quot;//打包后输出文件的文件名</span><br><span class="line">  &#125;,</span><br><span class="line">  devServer: &#123;</span><br><span class="line">    contentBase: &quot;./&quot;,//本地服务器所加载的页面所在的目录</span><br><span class="line">    historyApiFallback: true,//不跳转</span><br><span class="line">    inline: true//实时刷新</span><br><span class="line">  &#125; ,</span><br><span class="line">  plugins: [</span><br><span class="line">        new webpack.BannerPlugin(&apos;版权所有，翻版必究&apos;)</span><br><span class="line">    ],</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>通过这个插件，打包后的JS文件显示如下：<br><img src="/assets/blogImg/banner.png" alt=""><br>webpack还有很多常用的插件，具体用法请参照<a href="https://doc.webpack-china.org/concepts/plugins/" target="_blank" rel="noopener">官网</a></p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>至此，对于用webpack+vue搭建一个简单的骨架已经有了一定的理解，对项目运作机制以及各个组件间的引用也有了相应的了解，能够更好的探索其他关于webpack跟vue的知识。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h3&gt;&lt;p&gt;Vue-cli是官方提供的快速构建单页应用的脚手架，按官方文档跑了一遍确实非常强大，但牵扯的东西比较多，所以存在了一些疑惑，比如说整个项目是
      
    
    </summary>
    
    
      <category term="webpack" scheme="http://MoolamAfish.com/tags/webpack/"/>
    
      <category term="vue" scheme="http://MoolamAfish.com/tags/vue/"/>
    
  </entry>
  
</feed>
